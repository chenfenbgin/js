<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>图片懒加载</title>
    <style>
      img {
        display: block;
        height: 450px;
        margin-bottom: 20px;
      }
    </style>
  </head>

  <body>
    <img data-src="./images/1.jpg" alt="" />
    <img data-src="./images/2.jpg" alt="" />
    <img data-src="./images/3.png" alt="" />
    <img data-src="./images/1.jpg" alt="" />
    <img data-src="./images/2.jpg" alt="" />
    <img data-src="./images/3.png" alt="" />
  </body>
  <script>
    // 实现方案：
    //    在img元素时，自定义一个属性data-src，用于存放图片的地址；
    //    获取屏幕可视区域的尺寸；
    //    获取元素到窗口边缘的距离；
    //    判断元素时候在可视区域内，在则将data-src的值赋给src,否则，不执行其他操作；
    //    实质: 当图片在可视区域内时，才加载，否则不加载；也可一个给个默认的图片占位

    // 判断是否是在可视区域的三种方式
    //    屏幕可视区域的高度 + 滚动条滚动距离 > 元素到文档顶部的距离，document.documentElement.clientHeight + document.documentElement.scrollTop  >  element.offsetTop
    //    使用getBoundingClientRect()获取元素大小和位置；
    // IntersectionObserver 自动观察元素是否在视口内
    var imgs = document.querySelectorAll("img");

    // 节流函数,定时器版本
    function throttle(func, wait) {
      let timer = null;
      return function (...args) {
        if (!timer) {
          func(...args);
          timer = setTimeout(() => {
            timer = null;
          }, wait);
        }
      };
    }

    //方法1： H + S > offsetTop
    function lazyLoad1(imgs) {
      //offsetTop是元素与offsetParent的距离，循环获取直到页面顶部
      function getTop(e) {
        var T = e.offsetTop;
        while ((e = e.offsetParent)) {
          T += e.offsetTop;
        }
        return T;
      }
      var H = document.documentElement.clientHeight; //获取可视区域高度
      var S = document.documentElement.scrollTop || document.body.scrollTop;
      Array.from(imgs).forEach(function (img) {
        // +100 提前100个像素就开始加载
        // 并且只处理没有src即没有加载过的图片
        if (H + S + 100 > getTop(img) && !img.src) {
          img.src = img.dataset.src;
        }
      });
    }
    const throttleLazyLoad1 = throttle(lazyLoad1, 200);

    // 方法2：el.getBoundingClientRect().top <= window.innerHeight
    function lazyLoad2(imgs) {
      function isIn(el) {
        var bound = el.getBoundingClientRect();
        var clientHeight = window.innerHeight;
        return bound.top <= clientHeight + 100;
      }
      Array.from(imgs).forEach(function (img) {
        if (isIn(img) && !img.src) {
          img.src = img.dataset.src;
        }
      });
    }
    const throttleLazyLoad2 = throttle(lazyLoad2, 200);

    // 滚轮事件监听
    // window.onload = window.onscroll = function () {
    //   throttleLazyLoad1(imgs);
    //   // throttleLazyLoad2(imgs);
    // };

    // 方法3：IntersectionObserver
    function lazyLoad3(imgs) {
      const io = new IntersectionObserver((ioes) => {
        ioes.forEach((ioe) => {
          const img = ioe.target;
          const intersectionRatio = ioe.intersectionRatio;
          if (intersectionRatio > 0 && intersectionRatio <= 1) {
            if (!img.src) {
              img.src = img.dataset.src;
            }
          }
          img.onload = img.onerror = () => io.unobserve(img);
        });
      });
      imgs.forEach((img) => io.observe(img));
    }
    lazyLoad3(imgs);
  </script>
</html>
